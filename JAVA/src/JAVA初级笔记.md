<meta charset="utf-8">
<!-- lang=Java -->

# JAVA初级笔记
###### 作者:王永生

---
####基本语法
1. #####分支
	**if不是分支if...else是分支**

    ```Java
	switch(类型){
		case 1:
		...;
		break;
		case 2:
		...;
		break;
		 ......
	}
	```
	**类型:byte , short, int, char, String,枚举.**
2. #####循环
	* while执行`没有循环次数`的的循环,先判断后执行.
	* do有没有都执行一次,先执行后判断
	* for执行`有循环次数`的循环,先判断后执行.
3. #####数组
		int[] a = new int[5]//定义并初始化为5个单位,int占4个byte,总共占20byte
	* 从0下标开始访问
	* 初始化值:new代表是一个新的,int==>0,char==>空格,boolean==>false,浮点==>0.0,其他==>null,
	* 二维数组[行][列]
	* Array.sort(数组);对数组进行从小到大排序.需要导入包.C+S+O自动导入包
	* 有关两个数互换的三种方法,查看SIMS/两个数互换.java
4. #####++与--
	* **a\++,先进行运算后加1.++a,先加1后进行运算.**
5. #####运算符:
	* 算术运算符
	* 关系运算符
	* 逻辑运算符
	* 位移运算符
	* 赋值运算符
6. #####对象与类
	* **类:**类是有属性和函数来构成的,是抽象不存在的.用于定义对象,将共有的特征和行为,模子
	* **方法:**为实现特点目标而执行的一系列操作,共同的行为叫方法=函数.
	* **对象:**具体存在的东西.
	* **引用数据类型:**用new来开辟空间的(数组,类,接口).基本数据类型8个.
 			类名 对象名 = new 类名();
7. #####返回值
	* return可以返回值同时退出方法
8. #####static
	* 若使用static方法,可以直接使用` 对象名.方法名()`调用
	* 方法参数列表中可以直接用`对象  方法名(类名 对象名){}`直接使用对象
9. #####不规则的数组或叫动态数组(锯齿数组)
	* **行必须指定列不必指定**
    ```Java
	int a[][] = new [5][]; //只指定行不指定列
	a[0] =new [5];
	a[1] = new [77];
    ```
10. #####修饰符
	* default 默认的,包级别
	* (-)private 私有的,类级别
	* (*)protected 受保护的,子类类别
	* (+)public 公共的,所有可见的类中都能用
		**类图叫做UML**

11. #####代码块
	* 实例,类,局部,用{}表示一个区域
	* 作用:实例化级别可以给对象属性初始化,每个对象创建时调用一次
	* 类级别(static修饰的),可以给类属性初始化
12. #####构造器
	* 语法:` 修饰符+类名(参数列表){}`
	* 调用:` new构造器(参数列表值);`
	* 作用:创建对象,给属性初始化
	* 与方法的区别:方法有返回值类型,构造器无
	**在Java类中至少有一个构造器,没有时系统给我们提供一个空的构造器(无参,无对象),当你写了以后系统会自动加载例子:详见Eg02**
13. #####封装
	* 概念:将类的某些信息隐藏在类内部,不允许外部程序直接访问,而是通过该类提供的方法来实现隐藏信息的操作和访问.
	* 好处:a.只能通过规定的方法访问数据  b.隐藏类的实例细节,方便修改和实现
	* 目的:控制属性,用private修饰,对数据作保护,首字母小写.....粗浅理解,将变量用private藏起来,用方法去改变和读取,并加一定的条件
	* 实现步骤:
		1. 修改属性可见性(设为private)
		2. 创建getter/getter方法(用于属性的读写)
		3. 在gett/setter加入属性控制语句(对属性值的和合法性进行判断)
		* 复制方法(set方法):
			1. 修饰符类型public,返回值void
			2. 方法名称:规定用set+属性名(首字母大写), **若为boolean则用is+属性名(首字母大写)**
			3. 方法参数:一个参数,参数的类型与属性类型相同
			4. 方法体:通常有"属性 = 参数"

	```Java
    	例如: 类名.......{
			private int age;
			public void setAge(int age){
                if(age<=150){
                	this.age = age;//加以判断
                }else{
               	 this.age=150;//最大年龄
			}
		}
	```

	* ** this作用**
		1. 代表当前类的当前对象,为防止混淆,当局部变量和属性同名时
		2. 访问其他构造器 this(参数列表) !!必须放在有效代码的第一行
		* 读取数据方法(get方法):
			1. public修饰
			2. 返回值与属性一致
			3. 方法名称为get+属性(首字母大写)
			4. 方法参数为无参
			5. 方法体 通常有 `return 属性`

	```Java
	例如:public int getAge(){
	return Age;
	}
    ```
	例子:详见Eg01
14. #####重载
	* 判断是否重载:
		1.方法或构造器名必须相同
		2.参数必须不同(参数同可分为,类型不同,个数不同,顺序不同)不包括返回值类型
		例如:`Account()`与`Account(int a)`与`Account(String a)`可以并存
		例子:详见Eg02
15. #####static修饰符
 	* 指的是共享内存,类的数据为所有方法所共用,当一个改变他时,其他也会受到影响
 	* 作用:提升级别,将对象的方法或属性提升类的方法或属性.
 	* 加载顺序:先类的,后对象的
	* static可以修饰属性,方法,内部类
	* 当修饰属性时可以通过  类名.属性调用也可以用对象的属性(后者当然写多了,麻烦,并且对象的级别比类的级别低好多)
	* 访问顺序:
		1. 静态方法可以直接访问静态方法和属性,访问非静态时要用对象访问
		2. 非静态可以访问非静态成员方法和属性和静态成员的方法和属性
	**static 不能修饰局部变量public等修饰也一样**
		例子: 详见:Eg01
16. #####单例
	* 概念:就是单个实例,只创建一个对象

	```Java
	class 类名{
		private static 类名 对象名 =new 类名();	2)创建本类的一个实例作为当前类的一个静态属性
		private 类名(){						1)构造器私有化,外界类的不能直接访问.
		}
		public static 类名 方法名(){ 			3)如果这个实例是私有的创建一个静态方法返回这个实例
			return 对象名;
		}
	}
	/单例化								4)在外边通过"类名.静态方法()"返回这个实例
	//貌似现在只能比较两个对象是不是一致,不能输出语句
    ```
		例子:详见:Eg03
17. #####局部变量&&属性&&static修饰的区别
	* 局部变量:级别变量的范围取决于声明的大括号,超出范围局部变量立刻消失
	* 属性:属性是在调用构造器的时候被创建,通过垃圾回收机制自动回收
	* static:即类的数据,static修饰的属性,在类被加载的时候被创建,整个虚拟机停了以后销毁
	**能用局部变量不用属性,能用属性不用static修饰.用的static修饰的越多,内存占用越多,运行慢**
18. #####this&&super
	* 总结:都是有效代码的第一行,在一个构造器中this()和super()只能有一个,当然你可以创建多个构造器进行重载
		this:当前类的当前对象
        super:当前类的父类对象
	* 作用:
		* this 防止属性和局部变量混淆,this()调用当前类的当前构造器,防在有效代码的第一行.
		* super
			1. 防止混淆,子类成员(属性,方法)与父类成员(属性,方法)混淆,不能访问private属性
			2. super()调用当前类的父类对构造器,super(),默认调用父类无参无参构造器,如果父类没有无参构造器,则必须显示调用,调用父类的构造器只能在子类的构造器中,并且放在有效代码的第一行.
		例子:详见Eg04
19. #####继承		执行顺序:父类属性--父类构造器--子类属性---子类构造器
	1. 子类只继承父类的方法和属性,不继承构造器和private修饰的,即:public和protected修饰的
	2. 若封装时只有getter或setter时为只有只读只写属性,继承经常用到
	3. 父类和子类又叫基类和扩展类,只能是单继承,一个儿子只有一个亲爹,一个爹可以有好几个儿子,extends没有父类时,默认继承Obiect类
20. #####方法的重写
	* 概念:在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。
	* 要求:
		1. 修饰符,子类方法范围修饰>=父类方法的范围修饰,即:父类用protected,子类重写只能用public和protected
		2. 返回值类型,方法的名称,参数列表必须相同
		3. 方法必须在父子类中
21. #####方法重写与重载的区别
	1. 方法重写必须在父类,子类中.方法重载没有要求
	2. 方法重写只能重写 一次,方法重载可以多次
	3. 方法重写要求子类方法范围修饰大于等于父类方法范围修饰,方法重载没有要求
	4. 方法重写要求返回值必须相同,方法重载没要求
	5. 方法重写要求方法名相同,方法重载一样也要求方法名相同
	6. 方法重写要求方法参数列表必须相同,方法重载则要求参数列表不相同
	7. 方法重写要求子类方法抛出的异常小于等于父类方法抛出的异常,方法重载没有要求
22. #####final 最终的,可以修饰方法和类,
	1. final修饰变量,(属性和局部变量),变量变成常量
	2. final修饰方法,子类不能重写该方法
	3. final修饰类,这个类不能有子类.
	**常量全部用大写,下划线连接两个词**
23. #####equal与==
	1. equals比较的是内容
	1. ==比较的是地址
	1. String连接方法 `*.concat(*)`  不会保存在前一个*中,因为string是final静态

24. #####string&&Stringbuffer转换
	* 插入 `变量名.insert(插入索引位置,"");`
	* 删除 `变量名.delete(开始位置索引,结束位置);`

	```java
		String str="abc";
		//String转buffer
		StringBuffer s = new StringBuffer(str);
		//buffer转string
		String str1=s.toString(s);
	```
25. #####内存机制的简单理解
	* 数据栈:用于局部变量
	* 堆:用于对象的属性,即,new创建的   可以GC回收
	* 方法区:类的数据,方法,和字节码      不能GC回收
	* 常量:final修饰的,包装类,内容相同,在一块空间    GC不能回收
<div style="background-color: white;padding:10px;border: outset 3px black;">
<h3>有问题反馈</h3>
<h6>在阅读过程中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流<h6>
 QQ:421740482
[邮件](mailto:wissy@foxmail.com):wissy@foxmail.com
2016年1月5日</div>